# 4673(셀프 넘버)

> 문제설명

셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.

양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 

예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.

33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...

n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 

생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97

10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.

> 전체코드

```c++
#include <iostream>

using namespace std;

int result(int num); // 함수 선언
int n[10001]; // 전역변수로 배열 선언
int main() {
	for (int i = 1; i <= 10000; i++) {
		n[result(i)] = 1; // 생성자가 있는 값을 1로 바꿈
		if (!n[i]) cout << i << endl; // 생성자가 없는 값은 0이므로 출력
	}
	return 0;
}

int result(int num) {
	int sum = num;

	while (num != 0) {
		sum = sum + (num % 10); // d(n)함수 : n + n의 각 자리수
		num = num / 10;
	}

	return sum;
}
```

> 코드설명

1. result라는 이름으로 함수를 선언해준다. 이 함수는 전체적인 계산이 이루어질 함수이다.

2. 전역변수 int형으로 n이라는 배열을 하나 선언해준다. 전역변수로 변수를 선언할 경우 해당 변수는 자동으로 0으로 초기화된다. 또한 전역변수는 메모리의 데이터 영역에 할당되기 때문에 오버플로우가 발생하지 않는다.

3. result 함수에 int형 변수 sum을 선언해준다. 이 sum은 매개변수 num을 넘겨 받는다.

4. while문을 n이 0이 될 때까지 작동시킨다. 문제에선 본인과 본인의 각 자릿수들의 합이 생성자라고 했을 때 이 생성자를 가지지 않는 숫자를 셀프넘버라고 정의하고 있다. while문 안에서 sum과 num의 나머지를 더해  sum에 넣고 num 을 10으로 나눠 1의 자릿수를 지우고 다시 sum에 sum 과 num의 나머지를 더해 넣는 것을 반복한다. 이는 만약 숫자 33이 주어졌을 경우 생성자를 구하는 식인 33 + 3 + 3 = 39를 구현하기 위해 33과 33 % 10의 값 3을 더한 값 36을 가지고 33을 10으로 나눈 몫 3과 다시 더해 39를 구하는 것을 알고리즘으로 표현한 것이다.

5. result는 while문의 결과인 sum을 return한다.

6. main의 for문을 보면 배열 n의 인덱스에 result()를 넣어 해당 인덱스의 요소를 1로 만드는 라인이있다. 이는 바로 그 아래의 if문을 위한 것인데 result는 주어진 수의 생성자를 구하는 함수이기 때문에 결국 생성자를 갖지 않는 셀프 넘버를 구해야하기에 생성자가 있는 값을 1로 바꾸어  생성자를 가지는 값과 셀프 넘버를 구분해준다.

7. if문의 조건문에 !n[i]를 적어 n[i] 값이 1일 경우 if문에 진입하지 못하고 0일경우 i 값을 출력해준다.

   ​